/**动态规划:核心就是递推公式,以大化小
 * 动态规划解题步骤:
 * 1.找到问题,描述问题,看问题是否能化为更小的子问题
 * 2.找到大问题与子问题之间的关系确定dp数组表示的含义和下标的含义,尝试写出递推公式
 * 3.考虑边界问题,找到问题的边界情况,对dp数组进行初始化
 * 4.画出dp数组,确定dp数组的递推方向和遍历顺序,从哪开始,怎么走,到哪结束
 * 5.dp数组求解完毕,找到最终解的位置,返回答案
 * 
 * 总结来说,如果确定一个题可以用dp来做,则:dp数组的定义+dp数组的初始化+递推公式+遍历顺序,可以唯一确定一个结果集
 * 
 * dp常见题型:
 * 动态规划基础题:爬楼梯,斐波那契,只需要一维dp[i]数组就可以解决,这种题通常可以进行优化,将dp数组简化为单个变量
 * 经典题:通常是2维dp
 * 背包问题:背包,01背包
 * 打家劫舍:标准数组的dp,树形结构dp
 * 股票买卖问题
 * 子序列问题
 *
 * 动态规划:递推,自底向上,从小问题开始,一直求得最终问题
 * 递归:自顶向下,从大问题递归到小问题求解
 * 
 * 1.背包问题:最常见的是01背包,一种物品只能选一次,还有完全背包,每种物品可以随便拿无数次
 * 二维dp:dp[i][j]表示,从第0到i个物品任意选,背包容量为j时能拿的物品价值最大值,注意是[0,i]物品任意选!
 * 递推公式:dp[i][j]=max(dp[i-1][j],dp[i-1][j-weight[i]]+value[i])  dp[i-1][j-weight[i]]表示给新物品让地方
 * 二维dp的每个值都是由这个值的上方和左上方的值求解来的!
 * 初始化:第一行如果j>=weight[0],则后面的部分赋值为value[0],其他为0,第一列全部赋值为0
 * 遍历顺序:外层for正向遍历物品,内层for反向遍历背包容量,
 * 
 * 压缩状态:因为这个dp数组求解方向是从左到右,然后从上到下的一行一行求解,所以可以用滚动数组的方式求解!
 * 每次都更新这一行一维数组,
 * 则:dp[j]表示容量为j的背包所能拿的最大价值
 * dp[j]=max(dp[j],dp[j-weight[i]]+value[i])    必须保证j-weight[i]>=0
 * 这个递推公式是由二维递推公式压缩来的,也就是每次都刷新这一行数组,
 * 还记得我们求解二维数组的时候,dp[i][j]依赖其上方和左上方的值,所以内层必须从右向左遍历求解才不会覆盖错数据
 * 如果dp[j]比较大,相当于直接从上一行复制下来的也就是不放物品
 * 还是两层for循环,但是存储状态只用一个一维数组,注意数组的更新是从右向左的,因为计算每个值,其所依赖的值为其上方和左上方的值
 * 所以遍历顺序是:外层for遍历背包物品,内层for反向遍历背包容量
 * 初始化:一维数组全部初始化为0
 * 
 * 01背包问题有多少种拿法,这种题推荐用一维压缩数组来做,简单很多,dp[j]表示重量为j时有dp[j]种拿法
 * dp[j]=dp[j]+dp[j-nums[i]],表示不拿当前元素,和拿当前元素这两种拿法之和,初始化为dp[0]=1,不拿也是一种拿法
 * 滚动方向同01背包,外层正向遍历物品,内层反向遍历背包容量
 * 
 * 01背包还有种问法,就是能装最多的数量,这种情况dp[j]=max(dp[j],dp[j-nums[i]]+1) 意思就是不拿当前,那容量不变但是
 * 背包内数量也不变,如果拿当前,背包容量减少,背包中物品数量多了一个
 * 
 * 完全背包,与01背包dp公式很像,但是遍历顺序不一样,
 * 完全背包的遍历顺序是外层遍历背包容量,内层遍历背包物品,因为物品每次都要重新遍历一次(因为可以重复拿)
 * 完全背包的传统问题,for循环颠倒也可以过,先遍历物品还是背包都能过
 * 但是!如果涉及到组合和排列,则for循环非常讲究!组合问题一定先遍历物品防止排列重复
 * 如果是排列问题,一定先遍历背包,再遍历物品,确保每次遍历背包的时候都可以遍历到所有物品
 * 先遍历物品求的是组合数,先遍历背包求的是排列数
*/
let str='heeloworld'
console.log(str.split(''))
